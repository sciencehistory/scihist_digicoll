# This service class looks at all the files in the s3 directory where we store our
# video derivatives and links each one to a current video original.  It can either report
# a list of "orphans", or delete them.
#
# bundle exec rails runner 'OrphanS3VideoDerivatives.new(show_progress_bar: false).report_orphans'
class OrphanS3VideoDerivatives

  attr_reader :s3_iterator, :shrine_storage, :show_progress_bar, :sample, :orphans_found
  def initialize(show_progress_bar: true)

    @sample = []
    @shrine_storage = ScihistDigicoll::Env.shrine_video_derivatives_storage
    @show_progress_bar = show_progress_bar

    @s3_iterator = S3PathIterator.new(
      extra_prefix: 'hls/',
      first_level_only: true,
      shrine_storage: shrine_storage,
      show_progress_bar: show_progress_bar,
      progress_bar_total: video_asset_count,
    )
  end

  def video_asset_count
    @video_asset_count ||= Kithe::Asset.connection.select_one("select count(*) from kithe_models where kithe_model_type = 2 and file_data ->> 'storage' = 'video_store'")['count']
  end

  # This deletes all files and folders that can't be accounted for
  # as HLS derivatives.
  def delete_orphans
    delete_count = 0
    find_orphan_video_derivatives do |asset_id:, shrine_id:, s3_path:|
      shrine_storage.delete_prefixed(shrine_id)
      s3_iterator.log "deleted: #{shrine_storage.bucket.name}: #{s3_path}"
      delete_count += 1
    end
    $stderr.puts "\nDeleted #{delete_count} sets of orphaned derivatives"
  end

  def all_hls_deriv_folders
    # First iterate over all video derivs in s3.
    s3_iterator.each_s3_path do |all_derivs_for_asset|
      # all_derivs_for_asset is an s3 folder containing
      # all HLS derivatives for a particular asset.
      # The path ends in the asset id, e.g.
      # erubeiz.eddie-m1-laptop.local/derivatives_video/hls/0eadfd9b-c36b-4b02-a5e1-63a00a259410/
      S3PathIterator.new(
        extra_prefix: remove_prefix(all_derivs_for_asset),
        first_level_only: true,
        shrine_storage: shrine_storage,
        show_progress_bar: false,
      ).each_s3_path do |set_of_hls_derivs|
        # set_of_hls_derivs is an individual folder containing all the hls derivatives
        # generated by a particular request to mediaconvert, e.g.:
        #erubeiz.eddie-m1-laptop.local/derivatives_video/hls/0eadfd9b-c36b-4b02-a5e1-63a00a259410/2160f6d44ed781f81e7a4a66d5a0b117/
        yield set_of_hls_derivs
      end
    end
  end


  # Get a list of all HLS deriv info from the database.
  #
  # Ignores video assets with no HLS derivatives:
  # no derivatives means no orphaned derivatives.
  #
  # We don't anticipate having more than a few dozen videos in the first year or two.
  #
  # See infrastructure/aws-mediaconvert/README.md for more details
  # (including links to GitHub and the wiki) about
  # what goes in json_attributes->'hls_playlist_file_data'.
  def get_hls_derivs_from_db
      query = [
        # The hls_playlist_file_data; this is escaped and
        # stored as a string, so we need to extract the filepath using a trick described at 
        # https://dev.to/mrmurphy/so-you-put-an-escaped-string-into-a-json-column-2n67.
        "select (json_attributes->'hls_playlist_file_data' #>> '{}')::jsonb->>'id' as hls_info",
        
        # from assets
        "from kithe_models where kithe_model_type = 2",
        
        # of type video
        "and file_data ->> 'storage' = 'video_store'"

      ].join(" ")

      Kithe::Asset.connection.select_all(query).rows.map {|r| r[0]}.compact
  end

  def report_orphans
    max_reports = 20
    @orphans_found = 0

    files_checked = find_orphan_video_derivatives do |asset_id:, shrine_id:, s3_path:|
      @orphans_found +=1

      if @orphans_found == max_reports
        s3_iterator.log "Reported max #{max_reports} orphans, not listing subsquent...\n"
      elsif @orphans_found < max_reports

        @sample << s3_url_for_path(s3_path)
        asset = Asset.where(id: asset_id).first

        s3_iterator.log "orphaned video derivative"
        s3_iterator.log "  bucket: #{shrine_storage.bucket.name}"
        s3_iterator.log "  s3 path: #{s3_path}"
        s3_iterator.log "  asset_id: #{asset_id}"
        s3_iterator.log "  asset missing"  if asset.nil?
        s3_iterator.log ""
      end
    end

    $stderr.puts "\n\nTotal video asset count: #{video_asset_count}"
    $stderr.puts "Iterated through #{files_checked} video derivatives on S3"
    $stderr.puts "Found #{orphans_found} orphan files\n"
  end

  private

  # Will yield to block (asset_id, shrine_id, s3_path) for each derivative
  # determined to be an orphan.
  def find_orphan_video_derivatives
    video_assets_in_db = get_hls_derivs_from_db    
    all_hls_deriv_folders do |s3_path|
      shrine_id = remove_prefix(s3_path)
      unless video_assets_in_db.include? "#{shrine_id}hls.m3u8"
        # orphan found!
        hls, asset_id, hls_random_string = shrine_id.split('/')
        yield asset_id: asset_id, shrine_id: shrine_id, s3_path: s3_path
      end
    end
  end

  def bucket_prefix
    @bucket_prefix ||= if shrine_storage.prefix
      Regexp.escape(shrine_storage.prefix.chomp('/') + '/')
    else
      ''
    end
  end


  # We're not interested in the storage_prefix. What we want is what
  # shrine thinks of as the path on S3, and our way of accessing
  # and deleting the file if we determine it to be orphaned.
  def remove_prefix(s3_path)
    return s3_path if shrine_storage.prefix.nil?
    s3_path.delete_prefix(shrine_storage.prefix + "/")
  end


  # Note that the s3_path is the complete path on bucket. This might include a prefix
  # from the shrine storage already. For our report in the admin pages,
  # we just want a functioning URL that takes us directly to S3 if we need to investigate.
  def s3_url_for_path(s3_path)
    if shrine_storage.respond_to?(:bucket)
      shrine_storage.bucket.object(s3_path).public_url
    else
      shrine_storage.url(s3_path)
    end
  end
end